---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mxnorm: An R package to normalize multiplexed imaging data.

<!-- badges: start -->
<!-- badges: end -->

A package designed to handle multiplexed imaging data in R, implementing normalization methods and quality metrics detailed in our paper [here](https://doi.org/10.1101/2021.07.16.452359).

# Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ColemanRHarris/mxnorm")
```
# Analysis Example

This is a basic example using the `mx_sample` dataset, which is simulated data to demonstrate the package's functionality with slide effects.

```{r sample}
library(mxnorm)
head(mx_sample)
```

## `mx_dataset` objects

How to build the `mx_dataset` object with `mx_sample` data in the `mxnorm` package:

```{r example}
mx_dataset = mx_dataset(data=mx_sample,
                        slide_id="slide_id",
                        image_id="image_id",
                        marker_cols=c("marker1_vals","marker2_vals","marker3_vals"),
                        metadata_cols=c("metadata1_vals"))
```

The structure of the now built `mx_dataset` object:

```{r ex_str}
str(mx_dataset)
```

## Normalization with `mx_normalize()`

And now we can normalize this data using the `mx_normalize()` function:
```{r norm}
mx_norm = mx_normalize(mx_data = mx_dataset,
                       scale = "log10",
                       method="None")
```

The `mx_dataset` object has normalized data in the following form:

```{r norm_data}
head(mx_norm$norm_data)
```

And the `mx_dataset` object now includes the following attributes:

```{r norm_str}
str(mx_norm)
```

## Otsu misclassification metrics with `run_otsu_misclass()`

Using the above normalized data, we can run misclassification metrics to determine how well our normalization method performs:
```{r otsu}
mx_otsu = run_otsu_misclass(mx_norm,
                        table="both",
                        threshold_override = NULL,
                        plot_out = FALSE)
```

This adds an Otsu misclassification table to the `mx_dataset` object in the following form:
```{r otsu_data}
head(mx_otsu$otsu_data)
```

And the `mx_dataset` object now includes the following attributes:

```{r otsu_str}
str(mx_otsu)
```

## UMAP dimension reduction with `run_reduce_umap()`

We can also use the UMAP algorithm to reduce the dimensions of our markers in the dataset as follows, using the `metadata_col` parameter for later (e.g., similar to a tissue type in practice with multiplexed data):

```{r umap}
mx_umap = run_reduce_umap(mx_otsu,
                        table="both",
                        marker_list = c("marker1_vals","marker2_vals","marker3_vals"),
                        downsample_pct = 0.8,
                        metadata_col = "metadata1_vals")
```

This adds UMAP dimensions to our `mx_dataset` object in the following form (note the inclusion of `slide_id` as an identifier, which we'll use later):
```{r umap_data}
head(mx_umap$umap_data)
```

And the `mx_dataset` object now includes the following attributes:

```{r umap_str}
str(mx_umap)
```

## Variance components analysis with `run_var_proportions()`

We can also leverage `lmer()` from the `lme4` package to perform random effect modeling on the data to determine how much variance is present at the slide level, as follows:

```{r var,warnings=FALSE,message=FALSE}
mx_var = run_var_proportions(mx_umap,
                             table="both",
                             metadata_cols = "metadata1_vals")
```

This adds UMAP dimensions to our `mx_dataset` object in the following form:
```{r var_data}
head(mx_var$var_data)
```

And the `mx_dataset` object now includes the following attributes:

```{r var_str}
str(mx_var)
```

# Visualizations

We can also begin to visualize these results using some of `mxnorm`'s plotting features built using `ggplot2`. 

First, we can visualize the densities of the marker values as follows:

```{r mx_dens}
plot_mx_density(mx_otsu)
```

We can also visualize the results of the Otsu misclassification analysis stratified by slide and marker:

```{r mx_misc}
plot_mx_misclass(mx_otsu)
```

We can further visualize the results of the UMAP dimension reduction as follows:

```{r mx_umap}
plot_mx_umap(mx_umap,metadata_col = "metadata1_vals")
```

Note that since the sample data is simulated, we don't see separation of the groups like we would expect with biological samples that have some underlying correlation. What we can observe, however, is the separation of slides in the `raw` data and subsequent mixing of these slides in the `normalized` data:

```{r mx_umap_slide}
plot_mx_umap(mx_umap,metadata_col = "slide_id")
```

And we can also visualize the results of the variance proportions (note that this is sample data, hence the proportions of variance at the slide level are $\approx 0$):

```{r mx_var}
plot_mx_proportions(mx_var)
```

